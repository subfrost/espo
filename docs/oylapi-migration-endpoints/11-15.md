# Oylapi Endpoints 11-15 Implementation Plan

This file covers endpoints 11-15 from `agent-context/oyl-api.ts`, building on indices and rules established in `context/oylapi-migration-endpoints/1-5.md` and `context/oylapi-migration-endpoints/6-10.md`.

Assumptions from 1-5.md and 6-10.md (already implemented/approved):

- Ammdata owns canonical quotes and TOKEN/USD candles; prices are USD-only and all percent fields are multiplied by 100.
- Ammdata maintains `pool_creation_info` with creator ScriptPubKey taken from the protostone pointer output (LP receiver). If missing, fallback is acceptable but should not be relied on for correctness.
- Ammdata maintains `pools` (market defs), `factory_pools`, `pool_factory`, and pool-level activity logs.
- Oylapi should only call module-owned getters; storage.rs composes results.

## Activity entry enrichment (applies to all endpoints in this file)

We are extending ammdata `activity:v1` entries so that all endpoints in 11-15 can reuse the same enriched activity records.

New fields to add to `SchemaActivityV1` (activity entries):

| Field            | Type              | Purpose                                                                 |
| ---------------- | ----------------- | ----------------------------------------------------------------------- |
| `address_spk`    | `Vec<u8>`          | ScriptPubKey for the counterparty; derived from protostone pointer output. |
| `success`        | `bool`             | True for non-reverted; false for reverted if we can index them.          |

Notes:
- `address_spk` is the same derivation used for pool creation owner: the pointer output (LP receiver).
- For reverted traces: attempt to index with `success = false` if deltas are available; otherwise skip without failing the block.
- `lpTokenAmount` is the circulating supply of the pool (the pool alkane is the LP token).

---

### /get-pool-swap-history

#### Goal

Return swap history for a single pool, along with pool name and paging metadata.

#### Coverage

- Partially supported: uses ammdata activity entries, which will be enriched with `address_spk` and `success`.
- No swap-specific index is required once activity is enriched.

#### Inputs and validation

- `poolId` required.
- `count` defaults to 50, clamp 1..200.
- `offset` defaults to 0.
- `successful` defaults to false (if supported).
- `includeTotal` defaults to true.

#### Primary data sources (existing)

- Ammdata:
  - `activity:v1` (pool activity log) for swap events.
  - `pools` (market defs) for token0/token1 ids.
- Essentials:
  - `get_creation_record` for token labels to build pool name.

#### New indices required (and where)

- None new; reuse enriched `activity:v1` entries.

#### Implementation plan (write path)

1. While indexing activity, detect swaps (TradeBuy/TradeSell) and derive sold/bought tokens:
   - TradeSell (base in, quote out): sold = base, bought = quote.
   - TradeBuy (quote in, base out): sold = quote, bought = base.
2. Record sold/bought amounts using `abs(base_delta)` and `abs(quote_delta)`.
3. Derive address from the protostone pointer output (LP receiver) if available; store `address_spk` on the activity entry.
4. Attempt to index swaps that reverted:
   - If trace status is failure and we can still extract swap deltas, write activity with `success = false`.
   - Non-reverted swaps should be written with `success = true`.
   - If we cannot reliably index reverted swaps, skip them without failing the block.

#### Implementation plan (read path)

1. Validate `poolId` and pagination params.
2. Fetch pool name using `pools` + token labels.
3. Read enriched activity events for the pool (trade group), apply `offset` and `count`.
4. Map each activity item to `SwapHistoryItem`:
   - `transactionId` from txid.
   - `pay`/`receive` from sold/bought token ids and amounts.
   - `address` from scriptPubKey (if missing, use empty string).
   - `timestamp` as ISO string.
5. If `successful` is provided and activity entries include `success`, filter accordingly.
6. Return `PoolSwapHistoryResult` with `total` if `includeTotal` is true.

#### Missing getters to add (oylapi module)

- `get_pool_swap_history(pool_id, count, offset, include_total, successful?)`.
- `get_pool_name(pool_id)` (shared with /get-pool-details).

#### Caveats

- `SwapHistoryItem` does not require explicit buyer/seller fields; only a single counterparty `address` is returned.
- If address cannot be derived, return empty string in `address` fields.
- If total count is expensive without a count index, ignore `includeTotal` or return 0.

---

### /get-token-swap-history

#### Goal

Return swap history for a token across all pools.

#### Coverage

- Not supported without a token-based swap index; scanning all pools is O(n) and too slow.
- We will reuse the same **activity entries** as `/get-pool-swap-history` (with `address_spk` and `success`) and add a lightweight token->activity index that points to those entries.

#### Inputs and validation

- `tokenId` required.
- `count` defaults to 50, clamp 1..200.
- `offset` defaults to 0.
- `successful` defaults to false (if supported).
- `includeTotal` defaults to true.

#### Primary data sources (existing)

- None sufficient for fast access.

#### New indices required (and where)

- Ammdata:
  - `token_swaps/v1/<token_id>/<ts>/<seq> -> (ts, seq, pool_id)` referencing the existing activity entry.
  - `token_swaps/count/<token_id> -> u64` (optional for O(1) totals).

#### Implementation plan (write path)

1. When writing/augmenting activity entries for swaps, also add `token_swaps` index entries for both tokens in the swap.
2. The `token_swaps` index should reference the existing activity record (no new swap payload).

#### Implementation plan (read path)

1. Validate `tokenId` and pagination params.
2. Read `token_swaps` by prefix; page by `offset`/`count`.
3. For each entry, load the referenced activity event and map to `AmmSwapHistoryItem`:
   - Use sold/bought token ids and amounts derived from pool defs + deltas.
   - Pool id is present in the index key or reference payload.
   - Address from `address_spk` (empty string if missing).
   - Filter by `successful` if the activity entry includes `success`.
4. Return total if `includeTotal` is true.

#### Missing getters to add (oylapi module)

- `get_token_swap_history(token_id, count, offset, include_total, successful?)`.

#### Caveats

- If pool id is not stored in `SwapEventRecord`, omit `poolBlockId`/`poolTxId`.

---

### /get-pool-mint-history

#### Goal

Return liquidity add (mint) events for a pool.

#### Coverage

- Partially supported: activity has `LiquidityAdd` events and will now include `address_spk` and `success`.
- We will piggyback on enriched activity entries, and use pool circulating supply for `lpTokenAmount`.

#### Inputs and validation

- `poolId` required.
- `count` defaults to 50, clamp 1..200.
- `offset` defaults to 0.
- `successful` defaults to false (if supported).
- `includeTotal` defaults to true.

#### Primary data sources (existing)

- Ammdata:
  - `activity:v1` (pool activity log) for `LiquidityAdd`.
  - `pools` (market defs) for token0/token1 ids.

#### New indices required (and where)

- None new; reuse enriched `activity:v1` entries.

#### Implementation plan (write path)

1. Detect `LiquidityAdd` activity per pool at index time.
2. Derive token amounts from activity deltas (base/quote deltas).
3. Derive `lp_token_amount` as the circulating supply of the pool (pool alkane is the LP token).
4. Store `address_spk` (protostone pointer output) and `success` on the activity entry.
5. No separate mint index is required if activity is enriched as above.

#### Implementation plan (read path)

1. Validate `poolId` and pagination params.
2. Read enriched activity events for the pool filtered to `LiquidityAdd`.
3. Map each activity item to `AmmMintHistoryItem`:
   - Token ids from pool defs.
   - Amounts from activity deltas (abs values).
   - `lpTokenAmount` from the pool’s circulating supply.
   - Address from `address_spk` (empty string if missing).
   - Timestamp as ISO string.
4. If `successful` is provided and activity entries include `success`, filter accordingly.
5. Return `total` if `includeTotal` is true.

#### Missing getters to add (oylapi module)

- `get_pool_mint_history(pool_id, count, offset, include_total, successful?)`.

#### Caveats

- If LP token amount cannot be derived per tx, set `lpTokenAmount = "0"` and document missing data.

---

### /get-pool-burn-history

#### Goal

Return liquidity remove (burn) events for a pool.

#### Coverage

- Partially supported; will piggyback on enriched activity entries (`LiquidityRemove` + `address_spk`/`success`).

#### Inputs and validation

- `poolId` required.
- `count` defaults to 50, clamp 1..200.
- `offset` defaults to 0.
- `successful` defaults to false (if supported).
- `includeTotal` defaults to true.

#### Primary data sources (existing)

- Ammdata:
  - `activity:v1` (pool activity log) for `LiquidityRemove`.
  - `pools` (market defs) for token0/token1 ids.

#### New indices required (and where)

- None new; reuse enriched `activity:v1` entries.

#### Implementation plan (write path)

1. Detect `LiquidityRemove` activity per pool at index time.
2. Derive token amounts from activity deltas (base/quote deltas).
3. Derive `lp_token_amount` as the circulating supply of the pool (pool alkane is the LP token).
4. Store `address_spk` and `success` on the activity entry.

#### Implementation plan (read path)

1. Validate `poolId` and pagination params.
2. Read enriched activity events for the pool filtered to `LiquidityRemove`.
3. Map each activity item to `AmmBurnHistoryItem`:
   - Token ids from pool defs.
   - Amounts from activity deltas (abs values).
   - `lpTokenAmount` from the pool’s circulating supply.
   - Address from `address_spk` (empty string if missing).
   - Timestamp as ISO string.
4. If `successful` is provided and activity entries include `success`, filter accordingly.
5. Return `total` if `includeTotal` is true.

#### Missing getters to add (oylapi module)

- `get_pool_burn_history(pool_id, count, offset, include_total, successful?)`.

#### Caveats

- If LP token burn amount cannot be derived per tx, set `lpTokenAmount = "0"`.

---

### /get-pool-creation-history

#### Goal

Return pool creation events across all pools (global stream). Endpoint ignores `poolId` per current API spec.

#### Coverage

- Partially supported: `PoolCreate` activity exists per pool, and `pool_creation_info` stores creator and initial amounts, but a global creation stream and totals are missing.

#### Inputs and validation

- `count` defaults to 50, clamp 1..200.
- `offset` defaults to 0.
- `successful` defaults to false (if supported).
- `includeTotal` defaults to true.

#### Primary data sources (existing)

- Ammdata:
  - `pool_creation_info/v1/<pool>` for initial amounts and creator SPK.
  - `pools` for token0/token1 ids.
- Essentials:
  - `get_creation_record` for pool txid and creation timestamp.

#### New indices required (and where)

- Ammdata:
  - `pool_creations/v1/<ts>/<seq> -> CreationEventRecord` (global stream).
  - `pool_creations/count -> u64`.

Suggested `CreationEventRecord` fields:
- `txid`, `timestamp`, `pool_id`
- `token0_id`, `token1_id`
- `token0_amount`, `token1_amount`, `token_supply`
- `creator_spk` (Vec<u8>)
- `success` (bool)

#### Implementation plan (write path)

1. When a new pool is detected, write a `pool_creations` record:
   - Token ids from `pools` index.
   - Initial amounts and LP supply from `pool_creation_info`.
   - Creator address from protostone pointer output (LP receiver).
   - Timestamp/txid from pool creation record.
2. Update global count.

#### Implementation plan (read path)

1. Page through `pool_creations` index by prefix.
2. Map to `AmmCreationHistoryItem`:
   - `creatorAddress` from scriptPubKey (empty string if missing).
   - `tokenSupply` from creation info.
   - `timestamp` as ISO.
3. Return totals if `includeTotal` is true.

#### Missing getters to add (oylapi module)

- `get_pool_creation_history(count, offset, include_total, successful?)`.

#### Caveats

- If `poolId` is provided, it is ignored to match legacy behavior.

---

### Index definitions and data sources (new in 11-15)

#### `pool_swaps/v1/<pool>/<ts>/<seq>`

- Purpose: swap history per pool (for `/get-pool-swap-history`).
- Value: `SwapEventRecord`.
- Data source: activity indexing + pool defs.

#### `token_swaps/v1/<token>/<ts>/<seq>`

- Purpose: token swap history across pools (for `/get-token-swap-history`).
- Value: `SwapEventRecord`.
- Data source: derived from `pool_swaps` writes.

#### `pool_mints/v1/<pool>/<ts>/<seq>` / `pool_burns/v1/<pool>/<ts>/<seq>`

- Purpose: mint/burn history per pool.
- Value: `MintEventRecord` / `BurnEventRecord`.
- Data source: activity indexing + LP token delta extraction.

#### `pool_creations/v1/<ts>/<seq>`

- Purpose: global pool creation history.
- Value: `CreationEventRecord`.
- Data source: pool creation detection (`NewPoolInfo` + `pool_creation_info`).

#### Optional totals

- `*/count` keys for O(1) totals and `includeTotal` support.

---

### Overview: New getters after these 5 endpoints

#### New getters (oylapi module)

- `get_pool_swap_history(pool_id, count, offset, include_total, successful?)`.
- `get_token_swap_history(token_id, count, offset, include_total, successful?)`.
- `get_pool_mint_history(pool_id, count, offset, include_total, successful?)`.
- `get_pool_burn_history(pool_id, count, offset, include_total, successful?)`.
- `get_pool_creation_history(count, offset, include_total, successful?)`.

#### New getters (ammdata/essentials modules)

- Ammdata:
  - `get_pool_swaps(pool_id, offset, limit)`.
  - `get_token_swaps(token_id, offset, limit)`.
  - `get_pool_mints(pool_id, offset, limit)`.
  - `get_pool_burns(pool_id, offset, limit)`.
  - `get_pool_creations(offset, limit)`.
- Essentials:
  - `get_creation_record` (for pool txid + timestamp).
