# Oylapi Endpoints 16-20 Implementation Plan

This file covers endpoints 16-20 from `agent-context/oyl-api.ts`, continuing the format and assumptions in `context/oylapi-migration-endpoints/1-5.md`, `context/oylapi-migration-endpoints/6-10.md`, and `context/oylapi-migration-endpoints/11-15.md`.

## New module directive: `subfrost`

We must add a dedicated `subfrost` module that indexes frBTC wraps/unwraps and exposes its own RPC getters. This module should follow the same storage structure and conventions as `ammdata` and `essentials`:

- `subfrost/storage.rs` defines:
  - `MdbPointer` + `SubfrostTable` (root, indices, and key helpers).
  - All `get_` and `set_` functions for subfrost indices.
- `subfrost/main.rs` indexes wrap/unwrap events during trace processing.
- `subfrost` owns its database namespace and is the only module that directly accesses it.
- Oylapi calls subfrost getters only (no direct DB access).

Address determination for wrap/unwrap events:
- Use protostone pointer output SPK when available.
- Fallback to vin selection (lowest-value prevout SPK), same as pool creator logic.

Network-specific frBTC id:
- Add a `get_frbtc_alkane(network)` helper in `subfrost` (match by network).
- Use `get_frbtc_alkane` everywhere instead of hardcoding `invoke.context.myself`.
- Mainnet frBTC is `32:0`. Default non-mainnet to mainnet unless otherwise configured.

Wrap trace pattern (frBTC):
```
invoke.context.myself = get_frbtc_alkane(network)
invoke.context.inputs[0] = 0x4d   // wrap opcode
return.response.alkanes includes frBTC with minted value
```

Unwrap trace pattern (frBTC):
```
invoke.context.myself = get_frbtc_alkane(network)
invoke.context.inputs[0] = 0x4e   // unwrap opcode
invoke.context.incomingAlkanes includes frBTC burned value
return.response.data includes BTC amount (optional)
```

Amount derivation:
- Wrap amount: use frBTC minted value from `return.response.alkanes` for frBTC id.
- Unwrap amount: use frBTC burned value from `incomingAlkanes` for frBTC id.
- If multiple traces match, index each event independently; do not panic on partial data.

---

### /get-address-swap-history-for-pool

#### Goal
Return swap history for a given address within a specific pool.

#### Coverage
- Partially supported: activity entries include `address_spk` and `success`.
- Missing: address-aware activity index in ammdata.

#### Inputs and validation
- `address` required (BTC address).
- `poolId` required.
- `count` defaults to 50, clamp 1..200.
- `offset` defaults to 0.
- `successful` defaults to false.
- `includeTotal` defaults to true.

#### Primary data sources (existing)
- Ammdata: `activity:v1` (swap entries), `pools` (market defs).
- Essentials: `spk_to_address_str` for address formatting.

#### New indices required (ammdata)
- `address_pool_swaps/v1/<address_spk>/<pool>/<ts>/<seq> -> empty`
- Optional count index for totals:
  - `address_pool_swaps/count/<address_spk>/<pool> -> u64`

#### Implementation plan (write path)
1. When writing activity entries for `TradeBuy`/`TradeSell`, read `address_spk`.
2. If `address_spk` is empty, skip index (no address).
3. Write `address_pool_swaps` key using `<address_spk>/<pool>/<ts>/<seq>`.

#### Implementation plan (read path)
1. Convert `address` to scriptPubKey bytes.
2. Scan `address_pool_swaps` prefix with `<address_spk>/<pool>`, page by `offset`/`count`.
3. For each entry, load activity entry via `<pool>/<ts>/<seq>`.
4. Map to `AmmSwapHistoryItem` (same mapping as `/get-pool-swap-history`):
   - Sold/bought token ids from pool defs + delta signs.
   - Amounts from absolute deltas.
   - Address from `address_spk` (string).
   - `successful` filter if provided.
5. Include `total` if `includeTotal` is true (if count index exists).

#### Missing getters to add (oylapi)
- `get_address_swap_history_for_pool(address, pool_id, count, offset, include_total, successful?)`.

#### Caveats
- If no address index entry exists, return empty list.
- If `successful=true` is provided but success data missing, return only entries with `success=true`.

---

### /get-address-swap-history-for-token

#### Goal
Return swap history for a given address across all pools for a specific token.

#### Coverage
- Partially supported: activity entries include `address_spk` and `success`.
- Missing: address+token swap index.

#### Inputs and validation
- `address` required.
- `tokenId` required.
- `count` defaults to 50, clamp 1..200.
- `offset` defaults to 0.
- `successful` defaults to false.
- `includeTotal` defaults to true.

#### New indices required (ammdata)
- `address_token_swaps/v1/<address_spk>/<token>/<ts>/<seq>/<pool> -> empty`
- Optional count index:
  - `address_token_swaps/count/<address_spk>/<token> -> u64`

#### Implementation plan (write path)
1. On swap activity write, if `address_spk` present:
2. Write `address_token_swaps` for both tokens in the swap:
   - `<address_spk>/<token>/<ts>/<seq>/<pool>`.

#### Implementation plan (read path)
1. Convert `address` to scriptPubKey bytes.
2. Scan `address_token_swaps` prefix with `<address_spk>/<token>`, page by `offset`/`count`.
3. For each entry, load activity entry for `<pool>/<ts>/<seq>`.
4. Use pool defs to map sold/bought token ids and amounts.
5. Filter by `successful` if provided; map to `AmmSwapHistoryItem`.

#### Missing getters to add (oylapi)
- `get_address_swap_history_for_token(address, token_id, count, offset, include_total, successful?)`.

---

### /get-address-wrap-history

#### Goal
Return frBTC wrap events for a single address.

#### Coverage
- Not supported without subfrost.

#### Inputs and validation
- `address` required.
- `count` defaults to 50, clamp 1..200.
- `offset` defaults to 0.

#### Primary data sources (new)
- Subfrost:
  - `wrap_events_by_address/v1/<address_spk>/<ts>/<seq> -> WrapEventRef`
  - `wrap_events_all/v1/<ts>/<seq> -> WrapEventRecord`

#### Required subfrost indices
Suggested schema:
- `wrap_events_all/v1/<ts>/<seq>` -> `WrapEventRecord`
  - `txid`, `timestamp`, `amount`, `address_spk`, `success`
- `wrap_events_by_address/v1/<address_spk>/<ts>/<seq>` -> empty or `(ts, seq)`
- Optional `wrap_events_count` for total counts.

#### Implementation plan (write path)
1. Detect wrap call:
   - `context.myself` = frBTC id.
   - `context.inputs[0] == 0x4d`.
2. Extract frBTC minted amount from `return.response.alkanes` entry for frBTC id.
3. Determine address SPK (protostone pointer, fallback to lowest-value prevout).
4. Write `wrap_events_all` and `wrap_events_by_address`.

#### Implementation plan (read path)
1. Convert address to SPK bytes.
2. Read `wrap_events_by_address` by prefix, page by `offset`/`count`.
3. Fetch referenced `WrapEventRecord` and map to `WrapHistoryItem`:
   - `transactionId`, `address`, `amount`, `timestamp`.

#### Missing getters to add (oylapi)
- `get_address_wrap_history(address, count, offset)`.

---

### /get-address-unwrap-history

#### Goal
Return frBTC unwrap events for a single address.

#### Coverage
- Not supported without subfrost.

#### Inputs and validation
- `address` required.
- `count` defaults to 50, clamp 1..200.
- `offset` defaults to 0.

#### Primary data sources (new)
- Subfrost:
  - `unwrap_events_by_address/v1/<address_spk>/<ts>/<seq> -> UnwrapEventRef`
  - `unwrap_events_all/v1/<ts>/<seq> -> UnwrapEventRecord`

#### Required subfrost indices
Suggested schema:
- `unwrap_events_all/v1/<ts>/<seq>` -> `UnwrapEventRecord`
  - `txid`, `timestamp`, `amount`, `address_spk`, `success`
- `unwrap_events_by_address/v1/<address_spk>/<ts>/<seq>` -> empty or `(ts, seq)`
- Optional `unwrap_events_count` for total counts.

#### Implementation plan (write path)
1. Detect unwrap call:
   - `context.myself` = frBTC id.
   - `context.inputs[0] == 0x4e`.
2. Extract frBTC burned amount from `context.incomingAlkanes` for frBTC id.
3. Determine address SPK (protostone pointer, fallback to lowest-value prevout).
4. Write `unwrap_events_all` and `unwrap_events_by_address`.

#### Implementation plan (read path)
1. Convert address to SPK bytes.
2. Read `unwrap_events_by_address` by prefix, page by `offset`/`count`.
3. Fetch referenced `UnwrapEventRecord` and map to `WrapHistoryItem` (same type used for unwraps).

#### Missing getters to add (oylapi)
- `get_address_unwrap_history(address, count, offset)`.

---

### /get-all-wrap-history

#### Goal
Return global frBTC wrap events stream.

#### Coverage
- Not supported without subfrost.

#### Inputs and validation
- `count` defaults to 50, clamp 1..200.
- `offset` defaults to 0.

#### Primary data sources (new)
- Subfrost: `wrap_events_all/v1/<ts>/<seq>`.

#### Implementation plan (read path)
1. Page through `wrap_events_all` by prefix and offset.
2. Map records to `WrapHistoryItem`:
   - `transactionId`, `address` (from SPK), `amount`, `timestamp`.

#### Missing getters to add (oylapi)
- `get_all_wrap_history(count, offset)`.

#### Caveats
- If address SPK is missing, return empty string for `address`.

---

## Index definitions summary (new in 16-20)

### Ammdata
- `address_pool_swaps/v1/<address_spk>/<pool>/<ts>/<seq>`
- `address_token_swaps/v1/<address_spk>/<token>/<ts>/<seq>/<pool>`

### Subfrost
- `wrap_events_all/v1/<ts>/<seq> -> WrapEventRecord`
- `wrap_events_by_address/v1/<address_spk>/<ts>/<seq>`
- `unwrap_events_all/v1/<ts>/<seq> -> UnwrapEventRecord`
- `unwrap_events_by_address/v1/<address_spk>/<ts>/<seq>`

All records should include: `txid`, `timestamp`, `amount`, `address_spk`, `success`.
