First we will start by creating the `oylapi` module. E

Then Add the following config for oylapi:

- `alkane_icon_cdn` (string): base CDN URL to construct token image URLs (espo does not index images). Current base: `https://asset.oyl.gg/alkanes/mainnet`.
- `btc_usd_price_source` (object):
  - `endpoint` (string URL)
  - `field` (string JSON field to extract)
  - `refresh_interval` (seconds)
    The cached BTC/USD price should be shared across the oylapi module.
- `ord_endpoint` (optional string): ordinals RPC base URL for `/output/<outpoint>` queries.

Notes:

- `ord_endpoint` is optional; if absent, return empty `inscriptions` and `runes` for all UTXOs.
- `oyl api` (object, required) {host, port} -> defines where the oylapi HTTP server listens (only module that doesnt use espos main rpc server). This config is mandatory only when the oylapi module is enabled.
- Canonical pools are not configured here. Ammdata owns a `canonical_quotes` list returned by a function with a `match` on the active espo network (different networks can have different canonical quotes). Any pool whose quote token is in `canonical_quotes` is added to the `canonical_pool` index.
- Mainnet canonical quotes: frBTC = `32:0`, bUSD = `2:56801`.
- Non-mainnet canonical quotes: default to mainnet values.
- `btc_usd_price_source.field` is a top-level JSON field name (no nested path support).
- Ammdata exposes `price_feed` to read BTC/USD at a specific block (u128, 8 decimals). Only call it when AMM trades are present in the block.

Then start by implementing the following endpoints:

### /get-alkanes-by-address

#### Goal

Return the complete alkane balance set for a BTC address, enriched with token metadata (name/symbol), token image URL, price context (sats and USD), and holder/market stats when available.

#### Inputs and validation

- `address` in body.
- Normalize using the same rules as essentials (`normalize_address`), reject empty/invalid.

#### User comments (human) applied

- Images are fetched from an external CDN; espo does not index images.
- All alkane decimals are `8`.
- No pricing index: price comes from the TOKEN/USD chart’s last candle (always 10m).
- Create an `ammdata` index `alkane -> canonical_pool` (initialized empty). Any pool whose quote token is in `canonical_quotes` is added to this index.
- For any token with a canonical quote pool, ammdata builds a TOKEN/USD pair and 10m candles.
- Create a versioned circulating supply index in essentials:
  - `circulating_supply/<alkane_id>/<block_height> -> u128`
  - Update only when supply changes; this is the basis for FDV/marketcap.
- Price in USD should use ammdata `price_feed` during indexing (per-block, u128 with 8 decimals). Only call when AMM trades are present.
- `idClubMarketplace` is always `false`.
- Extend `AlkaneCreationRecord` to include `cap` and `mint_amount` by calling:
  - `get_cap` (opcode 102) and `get_value_per_mint` (opcode 104) if present in inspection metadata.
- Add `total_minted/v1/<alkane>/<height>` in essentials:
  - Update any time the alkane has a negative outflow of itself after `accumulate_alkane_balance_deltas` (negative outflow means the alkane was debited itself).
  - Add `abs(negative_outflow)` to `total_minted`.

#### Primary data sources (existing)

- Essentials balances index:
  - `/balances/<address>/<outpoint>` via `get_balance_for_address`.
- Essentials creation metadata:
  - `/alkanes/creation/id/<alkane>` via `get_creation_records_by_id`.
- Essentials holders count:
  - `/holders/count/<alkane>` (or `get_holders_for_alkane` as fallback).

#### New indices required (and where)

- Essentials:
  - `circulating_supply/v1/<alkane>/<height>` (versioned by block height).
  - Optional `circulating_supply/latest/<alkane>` for quick access.
- Ammdata:
  - `canonical_pool/v1/<alkane> -> { pool_id, price_unit }`.

#### Implementation plan (read path)

1. Validate and normalize address.
2. Fetch balances via `get_balance_for_address` (aggregated across unspent outpoints).
3. For each alkane id:
   - Name/symbol from creation record.
   - Decimals always `8`.
   - Image URL built as `{alkane_icon_cdn}/{alkaneId}.png` (current base `https://asset.oyl.gg/alkanes/mainnet`).
4. Pricing:
   - Read canonical pool mapping from ammdata index.
   - If canonical pool missing: return price fields as null.
   - Use 10m TOKEN/USD candles only.
   - TOKEN/USD candles are built by ammdata using canonical pools and `price_feed` for BTC/USD conversion (when needed).
5. Market stats:
   - Use latest circulating supply entry and price to compute FDV/marketcap.
6. Return balances with enriched fields; leave optional fields null if data missing.

#### Missing getters to add (oylapi module)

- `oyl_get_address_balances(address) -> Vec<(alkane_id, balance)>`.
- `oyl_get_canonical_pool(alkane_id) -> Option<{pool_id, price_unit}>`.
- `oyl_get_latest_candle_10m(pool_id) -> {close}` (wraps ammdata candles).
- `oyl_get_latest_token_usd_candle_10m(token_id) -> {close}` (wraps TOKEN/USD chart).
- `oyl_get_latest_circulating_supply(alkane_id) -> Option<u128>`.
- `oyl_get_btc_usd_price() -> f64` (cached, refreshed by config).

#### Caveats

- If canonical pool mapping is missing, do not attempt fallback pricing.
- Candle data may be missing early; treat as `null` price.
- Circulating supply index should only update on supply changes to avoid redundant entries.

---

### /get-alkanes-utxo

#### User comments (human) applied

- Add `ordinals.rs` in oylapi to query ordinals RPC for outpoint data.
- Use `GET /output/<OUTPOINT>` with JSON response.
- If `ord_endpoint` is missing, always return empty `inscriptions` and `runes`.
- Make `get-alkanes-utxo` a reusable function in `oylapi/storage.rs`.
- Piggyback on electrum-like’s script-hash UTXO lookup (`script_hash -> UTXOs`), which only exists in the electrs/esplora backend.
- If the server is started with electrum (no script-hash UTXO support) and the oylapi module is enabled, panic on startup.

#### Goal

Return the list of UTXOs for an address with embedded alkane balances per outpoint, plus BTC UTXO metadata (sats, confirmations, scriptPk, address) and ordinals fields.

#### Inputs and validation

- `address` in body.
- Normalize using essentials address rules; reject empty/invalid.

#### Primary data sources (existing)

- Electrum-like (electrs/esplora backend) script-hash UTXO lookup.
- Essentials outpoint indices:
  - `/outpoint_balances/<outpoint>` for alkane balance entries.

#### External data needed

- BTC UTXO value and confirmations (electrs/esplora backend required for script-hash UTXOs).
- Ordinals data (if `ord_endpoint` present).

#### Implementation plan (read path)

1. Normalize address.
2. Decode address to ScriptPubKey using bitcoin rust lib (use espo network).
3. Ask electrum-like for script-hash UTXOs (electrs/esplora backend).
4. For each UTXO returned, call the reusable `get-alkanes-utxo` path to enrich with alkane balances.
5. Fetch BTC UTXO data (sats, confirmations) and merge.
6. If `ord_endpoint` configured:
   - Call `GET /output/<outpoint>` and map `inscriptions` and `runes`.
   - Batch or throttle if needed to avoid per-UTXO request overload.
   - If request fails, fall back to empty structures.
7. If `ord_endpoint` not configured:
   - Always return empty `inscriptions` and `{}` for `runes`.

#### Missing getters to add (oylapi module)

- `oyl_get_address_outpoints(address) -> Vec<Outpoint>`.
- `oyl_get_outpoint_balances_batch(outpoints)`.
- `oyl_get_outpoint_spk_batch(outpoints)`.
- `oyl_get_utxo_btc_data_batch(outpoints)`.
- `oyl_get_ord_output(outpoint) -> Option<OrdOutput>` (in `ordinals.rs`, batch if needed).
- `oyl_get_script_hash_utxos(script_hash) -> Vec<Outpoint>` (electrs/esplora only).

#### Caveats

- Spent detection is encoded in `EspoOutpoint.tx_spent` within key; skip spent.
- If electrum backend is used with oylapi enabled, panic (no script-hash UTXO lookup).

---

### /get-amm-utxos

#### User comments (human) applied

- Reuse the `/get-alkanes-utxo` logic; make it a reusable function in `oylapi/storage.rs`.
- This endpoint is a misnomer: it returns address UTXOs for general usage (clean BTC UTXOs + all alkane UTXOs). No AMM-specific filtering.
- SpendStrategy shape (from @oyl/sdk): `{ addressOrder: AddressKey[]; utxoSortGreatestToLeast: boolean; changeAddress: AddressKey }`.
  Only `utxoSortGreatestToLeast` is honored; all other fields are ignored.

#### Goal

Return address UTXOs for spend selection: all alkane UTXOs plus clean BTC-only UTXOs.

#### Inputs and validation

- `address` in body.
- Optional `spendStrategy` is accepted; only `utxoSortGreatestToLeast` is honored.

#### Primary data sources (existing)

- Same outpoint sources as `/get-alkanes-utxo`.

#### Implementation plan (read path)

1. Reuse the shared `get_address_utxos` helper from `oylapi/storage.rs` (same as `/get-alkanes-utxo`) to get all UTXOs with BTC metadata, alkane balances, and ord info (if configured).
2. Partition UTXOs into:
   - Alkane UTXOs: any outpoint with non-empty alkane balances (always included).
   - Clean BTC UTXOs: no alkane balances AND no inscriptions/runes (best-effort if ord endpoint not configured).
3. Merge the two sets and de-dupe by outpoint.
4. If `spendStrategy.utxoSortGreatestToLeast` is true, sort by BTC value descending.
5. Return `{ utxos: [...] }`.

#### Missing getters to add (oylapi module)

- `oyl_get_address_utxos(address) -> Vec<FormattedUtxo>` (shared helper).

#### Caveats

- Clean BTC filtering depends on ord endpoint; if missing, treat inscriptions/runes as empty and do best-effort filtering.

---

### /get-alkanes

#### Goal

Paginated list of alkanes with sorting and search.

#### User comments (human) applied

- Use the existing holders-ordered index in essentials for `holders` sorting.
- Ammdata must maintain per-token indices updated on every trade with USD-only values:
  - price_usd
  - fdv_usd (from circulating_supply and price_usd)
  - marketcap_usd (from circulating_supply and price_usd)
  - volumeAllTime, volume1d, volume7d, volume30d (USD chart values)
  - change1d, change7d, change30d (percent change on USD chart)
- For timed indices, use block heights to compute windows; determine the best approach within espo’s architecture.
- Tokens with no pool against a canonical quote must have all USD metrics set to `0`.

#### Inputs and validation

- `limit` required.
- `offset` default 0.
- `sort_by` default `volumeAllTime`.
- `order` default `desc`.
- `searchQuery` optional string (name/symbol prefix or exact `block:tx`).

#### Primary data sources (existing)

- Essentials:
  - `/alkanes/creation/ordered` and `/alkanes/creation/count`.
  - `/alkanes/name/<prefix>` for name search.
  - `/alkanes/holders/ordered/` for holders sort.

#### New indices required (and where)

- Essentials:
  - `alkanes/symbol/<symbol>/<alkane>` for symbol search.
- Ammdata (updated on every trade):
  - `token_usd_candles/v1/<alkane>/<timeframe>/*` (TOKEN/USD candles). Store all timeframes supported by ammdata's existing candle system (same intervals and behavior as pool candles).
  - `token_metrics/v1/<alkane>` containing:
    - price_usd
    - fdv_usd
    - marketcap_usd
    - volume_all_time
    - volume_1d
    - volume_7d
    - volume_30d
    - change_1d
    - change_7d
    - change_30d
  - Optional per-field sort indexes for fast sorting.

#### Implementation plan (read path)

1. If `searchQuery` present:
   - If `block:tx`, resolve directly.
   - Else search name and symbol indexes; dedupe results.
2. If no search, use creation ordered list for baseline pagination.
3. Sorting:
   - If `holders`, use existing holders-ordered index.
   - For other metrics, use `token_metrics` + sort index; if missing, fallback to in-memory sort of candidate window.
4. For each alkane, attach name/symbol, image URL, and metrics from `token_metrics`.

#### Indexing plan (write path)

- On every trade activity in ammdata:
  - Before any writes, fetch BTC/USD for the block via `price_feed` (u128, 8 decimals). Do not call `price_feed` if there are no AMM trades in the block.
  - Identify tokens whose canonical pools changed in this block and update only those tokens' TOKEN/USD candles (all supported timeframes).
  - Build TOKEN/USD candles from canonical pools:
    - If token has a BTC-quoted pool, convert its candle to USD using `price_feed`.
    - If token has a USD-quoted pool, use it directly.
    - If both BTC and USD candles are active in the same bucket, merge with the neutral strategy:
      - high = avg(high_btc_usd, high_usd)
      - low = avg(low_btc_usd, low_usd)
      - open = previous TOKEN/USD close (or 0 if none)
      - close = avg(close_btc_usd, close_usd)
      - volume = volume_btc_usd + volume_usd
  - Use circulating supply from essentials at the current block height.
  - Update rolling windows by block height (track buckets keyed by height) based on the TOKEN/USD chart.
  - For price change, compare USD close at `now` vs close at `now - window` using TOKEN/USD candle history.
  - TOKEN/USD candles behave like ammdata's normal pool candles, except they are derived. Store and update all supported timeframes. Metrics windows should still be based on the 10m chart.

#### Caveats

- If a token has no canonical pool, metrics remain null.
- Use block height -> timestamp mapping from block summaries to approximate 1d/7d/30d windows.
- Ensure metrics updates are deterministic per block.

---

### OylAlkaneTokenRecord integration plan (AlkaneToken fields)

OylAlkaneTokenRecord is the denormalized record that the volume/change reverse indexes point to. It is assembled from essentials + ammdata at index time and served directly by `/get-alkanes` and related endpoints.

Field mapping plan (user can fill any TBD items):

| Field | Source | Notes / Default |
| --- | --- | --- |
| `id` | Alkane id | Always set `id` to `{block, tx}`. |
| `alkaneId` | Alkane id | Always set for legacy shape; same as `id`. |
| `name` | Essentials creation record | First name in `/alkanes/creation/id`. |
| `symbol` | Essentials creation record | First symbol in `/alkanes/creation/id`. |
| `totalSupply` | Essentials circulating_supply | Latest `circulating_supply/v1` (or `latest`). |
| `cap` | Essentials AlkaneCreationRecord | Call `get_cap` (opcode 102) at creation if present in inspection metadata; store in AlkaneCreationRecord. Default `0` if missing. |
| `minted` | Essentials total_minted index | Use `total_minted/v1/<alkane>/<height>` (latest) computed from negative self-outflows; default `0` if missing. |
| `mintActive` | Derived | `true` if `(cap * mintAmount) > total_minted`, else `false`. |
| `percentageMinted` | Derived | `total_minted / (cap * mintAmount)` as percent; `0` if denominator is 0. |
| `mintAmount` | Essentials AlkaneCreationRecord | Call `get_value_per_mint` (opcode 104) at creation if present in inspection metadata; store in AlkaneCreationRecord. Default `0` if missing. |
| `image` | CDN | `{alkane_icon_cdn}/{alkaneId}.png`. |
| `frbtcPoolPriceInSats` | Canonical BTC pool candle | 10m close in sats if BTC-quoted canonical pool exists; else `0`. |
| `busdPoolPriceInUsd` | Canonical USD pool candle | 10m close in USD if USD-quoted canonical pool exists; else `0`. |
| `maxSupply` | Derived | `cap * mintAmount` if both present in Essentials creation record; default `0` if absent. |
| `floorPrice` | TBD | User to fill; default `0` if absent. |
| `fdv` | Ammdata token_metrics | Use USD-based `fdv_usd` (circulating supply * price_usd). |
| `holders` | Essentials holders count | `/holders/count/<alkane>`. |
| `marketcap` | Ammdata token_metrics | Use USD-based `marketcap_usd` (circulating supply * price_usd). |
| `idClubMarketplace` | Constant | Always `false`. |
| `busdPoolFdvInUsd` | Derived | Alias of `fdv` when USD pool exists; else `0`. |
| `frbtcPoolFdvInSats` | Derived | `frbtcPoolPriceInSats * circulating_supply` if BTC pool exists; else `0`. |
| `priceUsd` | TOKEN/USD candle | 10m close from TOKEN/USD chart. |
| `fdvUsd` | Derived | Alias of `fdv`. |
| `busdPoolMarketcapInUsd` | Derived | Alias of `marketcap` when USD pool exists; else `0`. |
| `frbtcPoolMarketcapInSats` | Derived | `frbtcPoolPriceInSats * circulating_supply` if BTC pool exists; else `0`. |
| `tokenPoolsVolume1dInUsd` | Ammdata token_metrics | Use TOKEN/USD `volume_1d`. |
| `tokenPoolsVolume30dInUsd` | Ammdata token_metrics | Use TOKEN/USD `volume_30d`. |
| `tokenPoolsVolume7dInUsd` | Ammdata token_metrics | Use TOKEN/USD `volume_7d`. |
| `tokenPoolsVolumeAllTimeInUsd` | Ammdata token_metrics | Use TOKEN/USD `volume_all_time`. |
| `tokenVolume1d` | Ammdata token_metrics | Use TOKEN/USD `volume_1d`. |
| `tokenVolume30d` | Ammdata token_metrics | Use TOKEN/USD `volume_30d`. |
| `tokenVolume7d` | Ammdata token_metrics | Use TOKEN/USD `volume_7d`. |
| `tokenVolumeAllTime` | Ammdata token_metrics | Use TOKEN/USD `volume_all_time`. |
| `priceChange24h` | Ammdata token_metrics | Use TOKEN/USD `change_1d` (string percent). |
| `priceChange7d` | Ammdata token_metrics | Use TOKEN/USD `change_7d` (string percent). |
| `priceChange30d` | Ammdata token_metrics | Use TOKEN/USD `change_30d` (string percent). |
| `priceChangeAllTime` | Derived | Use first close and last close from TOKEN/USD 10m candles. |

Notes:
- If a token has no canonical quote pool, USD metrics should be `0` (and priceUsd `0`).\n

---

### /global-alkanes-search

#### Goal

Search across tokens and pools by name/symbol or exact `block:tx`.

#### Inputs and validation

- `searchQuery` required (non-empty).

#### Implementation plan (read path)

1. Normalize query to lowercase.
2. If query is exact `block:tx`:
   - Check token creation record; if found, include in `tokens`.
   - Check ammdata pool existence; if found, include in `pools`.
3. Token search:
   - Use name and symbol indexes to gather candidates.
4. Pool search:
   - Use pool name index (derived from token names/symbols).
5. Batch enrich tokens and pools with metadata and metrics where available.

#### New indices required (and where)

- Essentials:
  - `alkanes/symbol/<symbol>/<alkane>`.
- Ammdata:
  - `pool_name_index/<normalized>/<pool>`.

#### Caveats

- Without pool name index, pool search is O(n) and should be avoided.

---

### Overview: New indices and getters after these 5 endpoints

#### New indices

- Essentials:
  - `circulating_supply/v1/<alkane>/<height>` (versioned circulating supply).
  - `circulating_supply/latest/<alkane>` (optional shortcut).
  - `alkanes/symbol/<symbol>/<alkane>`.
- Ammdata:
  - `canonical_pool/v1/<alkane> -> { pool_id, price_unit }`.
  - `token_usd_candles/v1/<alkane>/<timeframe>/*` (TOKEN/USD candles).
  - `token_metrics/v1/<alkane>` (USD-only price, fdv, marketcap, volumes, changes).
  - `amm_utxos/v1/<address>/<outpoint>`.
  - `pool_name_index/<normalized>/<pool>`.

#### New getters (oylapi module)

- Address and UTXO helpers:
  - `oyl_get_address_balances(address)`
  - `oyl_get_address_utxos(address)`
  - `oyl_get_outpoint_balances_batch(outpoints)`
  - `oyl_get_outpoint_spk_batch(outpoints)`
  - `oyl_get_utxo_btc_data_batch(outpoints)`
  - `oyl_get_ord_output(outpoint)`
  - `oyl_get_amm_utxo_set(address)`
- Pricing and supply:
  - `oyl_get_canonical_pool(alkane_id)`
  - `oyl_get_latest_candle_10m(pool_id)`
  - `oyl_get_latest_token_usd_candle_10m(token_id)`
  - `oyl_get_latest_circulating_supply(alkane_id)`
  - `oyl_get_btc_usd_price()`
- Search and listing:
  - `oyl_search_tokens(query)`
  - `oyl_search_pools(query)`
  - `oyl_list_tokens_page(offset, limit)`
  - `oyl_sort_tokens(sort_by, order, offset, limit)`
