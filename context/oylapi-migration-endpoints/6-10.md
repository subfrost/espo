# Oylapi Endpoints 6-10 Implementation Plan

This file covers endpoints 6-10 from `agent-context/oyl-api.ts`, building on the indices and rules established in `context/oylapi-migration-endpoints/1-5.md`.

Assumptions from 1-5.md (already implemented/approved):

- `canonical_quotes` is owned by ammdata, returned by a network-matched function (default to mainnet values on non-mainnet). Mainnet: frBTC `32:0`, bUSD `2:56801`.
- `canonical_pool/v1/<alkane>` index exists in ammdata, populated when a pool has a quote in `canonical_quotes`.
- TOKEN/USD derived candles exist for all timeframes in ammdata (`token_usd_candles/v1/...`) and are computed only when canonical pools for a token change in a block; 10m candles drive metrics.
- `token_metrics/v1/<alkane>` exists in ammdata (USD-only values) and uses the derived TOKEN/USD candles.
- Essentials owns `circulating_supply` and `total_minted` indices, plus name/symbol indexes.
- Oylapi server is thin and calls getters in `src/modules/oylapi/storage.rs`, which in turn call module-owned getters only.

---

### /get-alkane-details

#### Goal

Return a single `AlkaneDetails` record that includes all `AlkaneToken` fields plus details like decimals, supply, priceInSatoshi, and tokenImage.

#### Coverage

- Mostly covered by indices from 1-5.md (creation record, token_metrics, TOKEN/USD candles, canonical pools).
- Missing if `token_metrics` or TOKEN/USD candles are absent for a token (price/volume/change fall back to 0).
- Optional gap: richer metadata (decimals beyond 8, image overrides) would require a `token_metadata` index.

#### Inputs and validation

- Body requires `alkaneId` with `{ block, tx }` strings.
- Parse to `SchemaAlkaneId`; reject invalid formats (non-numeric or missing fields).

#### User comments (human) applied

- priceInSatoshi is 0 if token metrics or token/usd candles are missing.

#### Primary data sources (existing)

- Essentials getters:
  - `get_creation_record` for name/symbol + cap/mint_amount.
  - `get_latest_circulating_supply` for `totalSupply`.
  - `get_latest_total_minted` for `minted`.
  - `get_holders_count` for `holders`.
- Ammdata getters:
  - `get_token_metrics` (USD-only metrics) for price/volumes/changes.
  - `get_latest_token_usd_close` (10m) for `priceUsd` fallback.
  - `get_canonical_pool_prices` for frBTC/bUSD pool prices.

#### New indices required (and where)

- None beyond 1-5.md for the core details fields.
- Optional (future): `token_metadata` if we need decimals or richer metadata beyond name/symbol (currently decimals = 8).

#### Field mapping plan (additions beyond AlkaneToken)

Use the `OylAlkaneTokenRecord` mapping from 1-5.md for base fields. Add the following fields for `AlkaneDetails`:

| Field            | Source                        | Notes / Default                                         |
| ---------------- | ----------------------------- | ------------------------------------------------------- |
| `decimals`       | Constant                      | Always `8` for alkanes.                                 |
| `supply`         | Essentials circulating_supply | Same as `totalSupply`.                                  |
| `priceInSatoshi` | Ammdata canonical BTC pool    | Use `frbtcPoolPriceInSats` (10m close); `0` if missing. |
| `tokenImage`     | CDN                           | `{alkane_icon_cdn}/{alkaneId}.png`.                     |

#### Implementation plan (read path)

1. Parse `alkaneId` and validate.
2. Load creation record via `get_creation_record`.
   - If missing, return `statusCode: 404` with error payload (consistent with other oylapi errors).
3. Fetch supply and minted:
   - `totalSupply` from `get_latest_circulating_supply`.
   - `minted` from `get_latest_total_minted`.
4. Compute mint fields:
   - `maxSupply = cap * mintAmount` (if either missing, treat as 0).
   - `mintActive = maxSupply > minted`.
   - `percentageMinted = minted * 100 / maxSupply` (0 if maxSupply is 0).
5. Pricing and USD metrics:
   - `priceUsd` from `token_metrics.price_usd` (fallback to latest TOKEN/USD 10m close if needed).
   - `frbtcPoolPriceInSats` and `busdPoolPriceInUsd` from `get_canonical_pool_prices`.
   - If no canonical pools, set price fields to `0`.
6. Volumes and changes:
   - Use `token_metrics` fields (USD-only) for all volume and change values.
7. Assemble `AlkaneDetails`:
   - Base fields from `OylAlkaneTokenRecord` mapping (1-5.md).
   - Add `decimals`, `supply`, `priceInSatoshi`, `tokenImage` as above.

#### Missing getters to add (oylapi module)

- `get_alkane_details(alkane_id) -> AlkaneDetails` (new oylapi storage getter that composes the above calls).
- Optional: `get_alkane_details_or_error` helper for standardized 404 behavior.

#### Caveats

- If the token has no canonical pools, set all USD-based metrics to `0`.
- `priceChangeAllTime` is already stored in `token_metrics.change_all_time` (derived from first and last 10m close).
- All percent fields returned by these endpoints are multiplied by `100` (percent units), not decimal fractions.

---

### /get-pools

#### Goal

Return all pool ids for a given factory, with pagination when requested.

#### Coverage

- Not fully supported until `factory_pools` is indexed; otherwise requires an O(n) scan of `reserves_snapshot`.
- Factory membership validation is not possible without `pool_factory` or `factory_pools`.

#### Inputs and validation

- `factoryId` required (`block`, `tx` as strings).
- `limit` optional; if null, return all pools.
- `offset` optional; default 0.

#### User comments (human) applied

- None provided. Maintain current contract that `limit`/`offset` may be ignored by legacy clients, but implement them if data access allows.

#### Primary data sources (existing)

- Ammdata:
  - `get_reserves_snapshot` contains all pools but does not map factory -> pools directly.

#### New indices required (and where)

- Ammdata:
  - `amm_factories/v1/<factory_id>` (set of discovered AMM factory ids).
  - `factory_pools/v1/<factory_id>/<pool_id>` (forward index).
  - Optional `pool_factory/v1/<pool_id> -> factory_id` (reverse lookup).

#### Implementation plan (read path)

1. Parse and validate `factoryId`.
2. Read `factory_pools` index to get pool ids.
3. Apply `offset` and `limit`.
4. Return `data: AlkaneId[]`, `total`, `offset`, and `limit`.

#### Indexing plan (write path)

- When a new alkane is created, first decide whether it is (or proxies) an AMM factory:
  - Read the creation inspection (from essentials creation record) and check its method opcodes.
  - Expected AMM factory opcodes (minimum set): `0,1,2,3,4,7,10,11,12,13,14,21,29,50` (create, swap, liquidity, fees, etc).
  - Expected inspection metadata shape (the field used for AMM factory detection):

```json
{
  "methods": [
    { "name": "init_factory", "opcode": "0", "params": [], "returns": "void" },
    {
      "name": "create_new_pool",
      "opcode": "1",
      "params": [],
      "returns": "void"
    },
    {
      "name": "find_existing_pool_id",
      "opcode": "2",
      "params": [],
      "returns": "void"
    },
    {
      "name": "get_all_pools",
      "opcode": "3",
      "params": [],
      "returns": "Vec<u8>"
    },
    {
      "name": "get_num_pools",
      "opcode": "4",
      "params": [],
      "returns": "Vec<u8>"
    },
    {
      "name": "set_pool_factory_id",
      "opcode": "7",
      "params": [],
      "returns": "void"
    },
    { "name": "collect_fees", "opcode": "10", "params": [], "returns": "void" },
    {
      "name": "add_liquidity",
      "opcode": "11",
      "params": [],
      "returns": "void"
    },
    { "name": "burn", "opcode": "12", "params": [], "returns": "void" },
    {
      "name": "swap_exact_tokens_for_tokens",
      "opcode": "13",
      "params": [],
      "returns": "void"
    },
    {
      "name": "swap_tokens_for_exact_tokens",
      "opcode": "14",
      "params": [],
      "returns": "void"
    },
    {
      "name": "set_total_fee_for_pool",
      "opcode": "21",
      "params": [],
      "returns": "void"
    },
    {
      "name": "swap_exact_tokens_for_tokens_implicit",
      "opcode": "29",
      "params": [],
      "returns": "void"
    },
    { "name": "forward", "opcode": "50", "params": [], "returns": "void" }
  ],
  "name": "AMMFactory"
}
```

- If the created alkane does not match, check for proxies:
  - Use essentials `get_keys` on the alkane to read `/implementation`.
  - Parse the `/implementation` value as two u128 LE values to get the proxy target alkane id.
  - If a proxy target exists, load its inspection and check the same opcode set.
- If the opcode check passes (directly or via proxy target), add the created alkane id to `amm_factories/v1`.
- When ammdata detects `NewPoolInfo` during indexing:
  - Detect pool creation by matching any AMM factory id in traces:
    - For each `invoke`, check if `inputs` begins with `[{factory_block},{factory_tx},"0x1", ...]` where `0x1` is create-new-pool and factory_block and factory_tx match any alkane we have stored in the amm_factories set.
    - The alkane created in the trace (`event: create`) is the pool id (example: `0x12d1f`).
  - If a match occurs, use the factory id u got from the amm_factories set and add the new pool to that factory_pools indicies
  - Write `factory_pools/<factory>/<pool>`.
  - Write `pool_factory/<pool> -> factory` (optional but helpful for validations).

#### Missing getters to add (oylapi module)

- `get_pools_by_factory(factory_id, offset?, limit?) -> { pools, total }`.

#### Caveats

- If `factory_pools` is absent, a fallback scan of `reserves_snapshot` is O(n) and should only be used as a temporary fallback.

---

### /get-pool-details

#### Goal

Return a detailed view of a pool, including reserves, TVL, volume windows, APR, and creation metadata.

#### Coverage

- Partially supported: reserves and token ids are available from `reserves_snapshot`.
- Missing until `pool_metrics`, `pool_creation_info`, and LP supply index are added; without these, TVL, volume windows, APR, and creation fields are unavailable.
- USD valuation depends on TOKEN/USD candles and canonical pools; pools with no canonical quotes report USD values as 0.

#### Inputs and validation

- `factoryId` required (used to validate pool membership).
- `poolId` required.

#### User comments (human) applied

- None provided; use the same pricing and metrics rules as in 1-5.md.

#### Primary data sources (existing)

- Ammdata:
  - `get_reserves_snapshot` for base/quote reserves and token ids.
  - `token_metrics` and TOKEN/USD candles for token pricing.
- Essentials:
  - `get_creation_record` for token name/symbol and for pool token display names.
  - `circulating_supply/latest` for LP token supply (if pool id maps to LP token id).

#### New indices required (and where)

- Ammdata:
  - `amm_factories/v1/<factory_id>` (set of AMM factories, discovered via opcode checks and proxy resolution).
  - `pool_metrics/v1/<pool_id>` (tvl, volume windows, apr, tvlChange).
  - `pool_creation_info/v1/<pool_id>` (creator address, initial reserves, creation height).
  - `pool_lp_supply/latest/<pool_id>` if we cannot rely on essentials `circulating_supply` for pool tokens.

#### Field mapping plan (PoolDetailsResult)

| Field                                         | Source             | Notes / Default                                                                    |
| --------------------------------------------- | ------------------ | ---------------------------------------------------------------------------------- |
| `token0` / `token1`                           | Ammdata pools index | Use `base_id` and `quote_id` from the pool record.                                |
| `token0Amount` / `token1Amount`               | Essentials alkane balance index | Read the pool alkane's balance for each reserve token id; these balances are the reserves. |
| `tokenSupply`                                 | LP supply          | Use pool LP supply index (or `circulating_supply/latest` if pool == LP token).     |
| `poolName`                                    | Token labels       | `SYMBOL0 / SYMBOL1` (fallback to name or `block:tx`).                              |
| `poolId`                                      | Input              | Echo `poolId`.                                                                     |
| `token0TvlInSats` / `token1TvlInSats`         | Derived            | Reserve value in sats using the token’s frBTC price ratio (same liquidity, sats unit). |
| `token0TvlInUsd` / `token1TvlInUsd`           | Derived            | Reserve value in USD using the token’s USD price ratio (same liquidity, USD unit). |
| `poolVolume30dInSats` / `poolVolume1dInSats`  | pool_metrics       | Store precomputed sats volumes.                                                    |
| `poolVolume30dInUsd` / `poolVolume1dInUsd`    | pool_metrics       | Store precomputed USD volumes.                                                     |
| `token0Volume30d` / `token1Volume30d`         | pool_metrics       | Raw token volumes (alks).                                                          |
| `token0Volume1d` / `token1Volume1d`           | pool_metrics       | Raw token volumes (alks).                                                          |
| `lPTokenValueInSats` / `lPTokenValueInUsd`    | Derived            | pool TVL / LP supply.                                                              |
| `poolTvlInSats` / `poolTvlInUsd`              | Derived            | Sum token TVLs.                                                                    |
| `tvlChange24h` / `tvlChange7d`                | pool_metrics       | Percent change strings.                                                            |
| `totalSupply`                                 | Alias              | Same as `tokenSupply`.                                                             |
| `poolApr`                                     | pool_metrics       | APR percent.                                                                       |
| `initialToken0Amount` / `initialToken1Amount` | pool_creation_info | Creation amounts.                                                                  |
| `creatorAddress`                              | pool_creation_info | Address if known.                                                                  |
| `creationBlockHeight`                         | pool_creation_info | Block height at creation.                                                          |
| `tvl` / `volume*` / `apr` / `tvlChange`       | Legacy aliases     | Mirror `poolTvlInUsd`, `poolVolume*InUsd`, `poolApr`, `tvlChange24h` where needed. |

#### Implementation plan (read path)

1. Parse `factoryId` and `poolId`.
2. Validate `poolId` belongs to factory (use `factory_pools` or `pool_factory`).
3. Load pool snapshot from `get_reserves_snapshot`; if missing, return `{ statusCode: 200, data: null }`.
4. Load token creation records for token0/token1 to build `poolName`.
5. Load token prices:
   - USD price from `token_metrics.price_usd` (fallback to latest TOKEN/USD 10m close).
   - Sats price from `get_canonical_pool_prices` (frBTC only).
6. Load pool metrics from `pool_metrics` (if missing, default volumes/changes to 0).
7. Load LP supply (pool token supply). If unavailable, treat as 0 to avoid divide-by-zero.
8. Derive TVLs and LP token value, and populate fields.
9. Attach creation metadata from `pool_creation_info` if present.

#### Indexing plan (write path)

- On each pool update (trade or liquidity event):
  - Update `pool_metrics` with USD and sats volumes, TVL, APR, and TVL change windows.
  - Use TOKEN/USD charts and canonical prices to compute USD values.
- On pool creation:
  - Detect creation by matching any `amm_factories` id in `inputs`:
    - `[{factory_block},{factory_tx},"0x1", ...]` where `0x1` is create-new-pool.
    - Use the corresponding `create` event alkane id as the pool id.
  - Read `/factory_id` from the pool storage writes in the same trace to determine the factory id (do not use essentials factory metadata).
  - Capture initial reserves, LP supply, creator address, and creation height into `pool_creation_info`.
  - Write `factory_pools`/`pool_factory` indices.

#### Missing getters to add (oylapi module)

- `get_pool_details(factory_id, pool_id) -> PoolDetailsResult | null` (compose snapshot + metrics + metadata).
- `get_pool_metrics(pool_id)` in ammdata.
- `get_pool_creation_info(pool_id)` in ammdata.
- `get_pool_lp_supply(pool_id)` (either essentials or ammdata).

#### Caveats

- Tokens without canonical pools will report `token*TvlInUsd = 0`.
- If LP supply is zero, LP token value should be `0` to avoid division errors.

---

### /address-positions

#### Goal

Return LP positions for an address, including per-pool TVL share and USD/sats valuation.

#### Coverage

- Partially supported: address balances exist in essentials.
- Missing until `amm_factories` discovery + `factory_pools` indexing is in place; without those, LP positions cannot be identified per factory.
- Valuation requires `pool_metrics` and LP supply indices; without them, TVL share and USD/sats values are unavailable.
- Requires `get_pool_details` to be available for per-pool valuation.

#### Inputs and validation

- `address` required; normalize using essentials rules.
- `factoryId` required; used to filter pools.

#### User comments (human) applied

- None provided; use same pricing and supply rules from 1-5.md.

#### Primary data sources (existing)

- Essentials:
  - `get_balance_for_address` to retrieve all token balances for an address.
- Ammdata:
  - `factory_pools` index (built from `amm_factories` detection) to identify LP tokens (pool ids).
  - `pools` index for token0/token1 ids.
  - `token_metrics` and TOKEN/USD candles for USD prices.
  - `pool_metrics` for per-pool volume/TVL windows.

#### New indices required (and where)

- Same as `/get-pool-details`: `pool_metrics`, `pool_creation_info`, and LP supply index.

#### Implementation plan (read path)

1. Normalize and validate address.
2. Load address balances via `get_balance_for_address`.
3. Load factory pool ids (`factory_pools`) and filter balances to pool ids only.
4. For each pool balance:
   - Fetch pool details (reuse `get_pool_details` helper backed by `pools` + essentials balances for reserves).
   - Fetch LP supply and compute share: `lp_balance / lp_supply`.
   - Compute user amounts:
     - `token0ValueInUsd = pool.token0TvlInUsd * share`.
     - `token1ValueInUsd = pool.token1TvlInUsd * share`.
     - Same for sats values.
   - Compute totals: `totalValueInUsd` and `totalValueInSats`.
   - Attach `balance` field (LP balance).
5. Return the list sorted by `totalValueInUsd` descending (optional but helpful).

#### Missing getters to add (oylapi module)

- `get_address_positions(address, factory_id) -> AddressPoolPosition[]`.
- `get_pool_details` (reused from endpoint above) should accept pool id and return full details.

#### Caveats

- If LP supply is zero or missing, the position value should be `0`.
- If pool details cannot be resolved (missing snapshot), skip that pool.

---

### /get-all-pools-details

#### Goal

Return a paginated pool list with metrics, sorting, search, trending pools, largest pool, and aggregate totals.

#### Coverage

- Partially supported: pool list and reserves exist, and pool name search is available via `pool_name_index`.
- Missing until `pool_metrics` exists; without it, sorting by TVL/volume/APR and aggregate totals are unavailable.
- Trending and largest pool require a stable metric (e.g., 1d volume or TVL change) and a precomputed index or an O(n) scan.

#### Inputs and validation

- `factoryId` required.
- `limit` optional; `null` means return all pools.
- `offset` optional; default `0`.
- `sort_by` optional; default `tvl`.
- `order` optional; default `desc`.
- `address` optional; if present, filter pools to those where address holds LP tokens.
- `searchQuery` optional; match pool name or token id.

#### User comments (human) applied

- None provided; use 1-5.md pricing and USD-only metrics behavior.

#### Primary data sources (existing)

- Ammdata:
  - `factory_pools` for pool listing.
  - `pool_name_index` for search.
  - `get_reserves_snapshot` for base pool data.
  - `token_metrics` for token pricing.
- Essentials:
  - `get_creation_record` for token labels.

#### New indices required (and where)

- Ammdata:
  - `pool_metrics/v1/<pool_id>` for sorting, totals, and trend.
  - `pool_sort_index/<sort_key>` (optional optimization).
  - `pool_trending/1d` (optional) for quick trending pools.

#### Implementation plan (read path)

1. Parse `factoryId`, `offset`, `limit`, `sort_by`, `order`, `address`, `searchQuery`.
2. Pool candidate set:
   - Start from `factory_pools` list.
   - If `searchQuery`:
     - If `block:tx`, restrict to that pool id.
     - Else use `pool_name_index` to find pools by name.
     - If query matches a token id, optionally intersect with `token_pools` if that index exists.
   - If `address`:
     - Load address LP balances and intersect with candidate pools.
3. For each candidate pool:
   - Build `PoolDetailsResult` using `get_pool_details`.
4. Sorting:
   - Primary sort uses `pool_metrics` fields (tvl, volume, apr, etc).
   - If sort field is missing, default to `tvl`.
5. Pagination:
   - Apply `offset` and `limit` (if null, return all).
6. Aggregate fields:
   - `largestPool`: max `poolTvlInUsd`.
   - `trendingPools["1d"]`: highest `poolVolume1dInUsd` or `tvlChange24h` (choose a consistent metric and document it).
   - `totalTvl`: sum of `poolTvlInUsd` across candidates.
   - `totalPoolVolume24h`: sum of `poolVolume1dInUsd` across candidates.
   - `totalPoolVolume24hChange`: derive from aggregate window close, or keep placeholder if not tracked yet.

#### Missing getters to add (oylapi module)

- `get_all_pools_details(factory_id, params) -> { pools, totals, largest, trending }`.
- `get_pool_ids_by_name_prefix` (already exists in ammdata) should be used for `searchQuery`.
- `get_pool_metrics` in ammdata to support sorting and totals.

#### Caveats

- Without `pool_metrics`, sorting and aggregates will be O(n) and should be limited to small lists.
- Trending pools require a chosen definition (volume or TVL change); pick one and keep it stable.

---

### Index definitions and data sources (new in 6-10)

This section documents the new indices referenced above, their on-disk shape, and where the data comes from. These are needed because ammdata currently only exposes `reserves_snapshot`, `token_metrics`, `activity`, and pool candles — there are no pool-level metrics or factory/pool indexes to piggyback on for O(1) reads.

#### `amm_factories/v1/<factory_id>`

- Purpose: set of AMM factory alkane ids discovered at creation time.
- Key: `amm_factories/v1/<factory_id>` (value can be empty bytes; presence == membership).
- Data source: essentials creation inspection metadata.
  - Check `inspection.metadata.methods` opcodes for the AMM factory method set.
  - If a proxy, read `/implementation` key via essentials `get_keys` and check the proxy target’s inspection metadata.
- Update trigger: on alkane creation; add if opcode set matches (directly or via proxy).

#### `factory_pools/v1/<factory_id>/<pool_id>`

- Purpose: forward index from factory -> pools for `/get-pools` and `/address-positions`.
- Key: `factory_pools/v1/<factory_id>/<pool_id>` (value empty or minimal metadata).
- Data source: ammdata trace processing when a pool is created by an AMM factory.
  - Detect pool creation by `inputs` starting with `[{factory_block},{factory_tx},"0x1", ...]`.
  - Use the created alkane id from the `create` event as `pool_id`.
  - Use `/factory_id` storage write from the pool creation trace (not essentials factory) as `factory_id`.
- Update trigger: pool creation only (append-only index).

#### `pool_factory/v1/<pool_id> -> factory_id` (optional)

- Purpose: reverse lookup for validation and quick membership checks.
- Value: factory id (encoded as two u128 LE or `SchemaAlkaneId` borsh, consistent with other indices).
- Data source: same as `factory_pools`.

#### `pool_metrics/v1/<pool_id>`

- Purpose: precomputed, O(1) pool metrics used by `/get-pool-details`, `/address-positions`, `/get-all-pools-details`.
- Suggested schema (borsh-encoded):
  - `token0_volume_1d`, `token1_volume_1d`, `token0_volume_30d`, `token1_volume_30d` (u128, raw alks).
  - `pool_volume_1d_usd`, `pool_volume_30d_usd` (u128, PRICE_SCALE).
  - `pool_volume_1d_sats`, `pool_volume_30d_sats` (u128, PRICE_SCALE; sats unit scaled to PRICE_SCALE).
  - `pool_tvl_usd`, `pool_tvl_sats` (u128, PRICE_SCALE).
  - `tvl_change_24h`, `tvl_change_7d` (string percent, already multiplied by 100).
  - `pool_apr` (string or f64 percent, already multiplied by 100).
- Data sources:
  - Reserves: essentials alkane balance index for the pool alkane id and the pool’s `token0`/`token1` ids.
  - Prices:
    - USD: token `token_metrics.price_usd` (or latest TOKEN/USD 10m close).
    - sats: token frBTC price via `get_canonical_pool_prices`.
  - Volumes:
    - Aggregate pool trade activity by token from ammdata activity stream at index time.
    - Windows (1d/30d) derived from activity timestamps (10m buckets used elsewhere).
  - TVL change:
    - Derived by comparing current TVL vs historical TVL at 1d/7d boundaries using the versioned TVL index below.
- Update trigger: on any pool trade or liquidity event.

#### `pool_creation_info/v1/<pool_id>`

- Purpose: capture pool creation metadata (used in `/get-pool-details`).
- Suggested schema:
  - `creator_address`, `creation_height`
  - `initial_token0_amount`, `initial_token1_amount` (raw alks)
  - `initial_lp_supply` (raw alks)
- Data source: pool creation trace (storage writes + incoming alkanes).
- Creator address derivation (Bitcoin-style heuristic):
  - If multiple vins, pick the scriptPubKey of the **lowest-value** vin’s prevout.
  - If a single vin, use that vin’s prevout scriptPubKey.
- Update trigger: pool creation only.

#### `pool_lp_supply/latest/<pool_id>`

- Purpose: fast LP supply lookup when pool == LP token.
- Data source: essentials circulating supply or direct pool storage `/totalsupply` (if tracked).
- Update trigger: whenever LP supply changes.

#### `tvlVersioned/<pool_id>/<height>`

- Purpose: versioned TVL history for accurate `tvlChange24h`/`tvlChange7d` without approximations.
- Key: `tvlVersioned/<pool_id>/<height> -> tvl` (tvl stored in USD using `PRICE_SCALE`).
- Data source: compute TVL at index time using current pool reserves and token prices.
- Update trigger: on any trade, liquidity add, or liquidity remove for the pool.
- Window lookup rule:
  - For a target height `n - 144` (1d) or `n - 1008` (7d), read the nearest entry **at or before** that height.
  - If the exact height is missing, use the most recent prior entry (e.g., if `n-144` missing but `n-147` exists, use `n-147`).

#### Optional sort/aggregation helpers

- `pool_sort_index/<field>`: ordered index for fast sorting by TVL/volume/APR.
- `pool_trending/1d`: precomputed top pools by 1d volume or TVL change.
- Data source: derived from `pool_metrics` writes at block time.

---

### Overview: New indices and getters after these 5 endpoints

#### New indices

- Ammdata:
  - `amm_factories/v1/<factory>` (discovered AMM factory ids, including proxy targets).
  - `factory_pools/v1/<factory>/<pool>` and optional `pool_factory/v1/<pool> -> factory`.
  - `pool_metrics/v1/<pool>` (tvl, volumes, apr, tvlChange windows).
  - `pool_creation_info/v1/<pool>` (creator, creation height, initial reserves).
  - `pool_lp_supply/latest/<pool>` (if LP supply cannot rely on essentials `circulating_supply`).
  - Optional `pool_sort_index/<field>` and `pool_trending/1d` for faster sorting/trending.

#### New getters (oylapi module)

- `get_alkane_details(alkane_id)`.
- `get_pools_by_factory(factory_id, offset?, limit?)`.
- `get_pool_details(factory_id, pool_id)`.
- `get_address_positions(address, factory_id)`.
- `get_all_pools_details(factory_id, params)`.

#### New getters (ammdata/essentials modules)

- Ammdata:
  - `get_pool_metrics(pool_id)`.
  - `get_pool_creation_info(pool_id)`.
  - `get_pools_by_factory(factory_id)` (wraps `factory_pools`).
  - `get_pool_lp_supply(pool_id)` (if stored in ammdata).
- Essentials:
  - `get_creation_record` (already exists; used for token labels).
  - `get_latest_circulating_supply` (already exists; used for LP supply if pool id maps to LP token).
